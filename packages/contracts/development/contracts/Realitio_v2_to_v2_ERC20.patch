4a5
> 
7,8c8
< import './BalanceHolder.sol';
< 
---
> import './BalanceHolderERC20.sol';
10c10
< contract Realitio is BalanceHolder {
---
> contract RealitioERC20 is BalanceHolder {
174,176c174,176
<     modifier bondMustDouble(bytes32 question_id) {
<         require(msg.value > 0, "bond must be positive"); 
<         require(msg.value >= (questions[question_id].bond.mul(2)), "bond must be double at least previous bond");
---
>     modifier bondMustDouble(bytes32 question_id, uint256 tokens) {
>         require(tokens > 0, "bond must be positive"); 
>         require(tokens >= (questions[question_id].bond.mul(2)), "bond must be double at least previous bond");
186a187,193
>     function setToken(IERC20 _token) 
>     public
>     {
>         require(token == IERC20(address(0x0)), "Token can only be initialized once");
>         token = _token;
>     }
> 
237c244
<     public payable returns (bytes32) {
---
>     public returns (bytes32) {
242c249
<     /// @notice Ask a new question and return the ID
---
>     /// @notice Ask a new question without a bounty and return the ID
243a251,252
>     /// @dev Calling without the token param will only work if there is no arbitrator-set question fee.
>     /// @dev This has the same function signature as askQuestion() in the non-ERC20 version, which is optionally payable.
253c262,289
<     public payable returns (bytes32) {
---
>     public returns (bytes32) {
> 
>         require(templates[template_id] > 0, "template must exist");
> 
>         bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));
>         bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, msg.sender, nonce));
> 
>         _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, 0);
>         emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);
> 
>         return question_id;
>     }
> 
>     /// @notice Ask a new question with a bounty and return the ID
>     /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.
>     /// @param template_id The ID number of the template the question will use
>     /// @param question A string containing the parameters that will be passed into the template to make the question
>     /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute
>     /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer
>     /// @param opening_ts If set, the earliest time it should be possible to answer the question.
>     /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.
>     /// @param tokens The combined initial question bounty and question fee
>     /// @return The ID of the newly-created question, created deterministically.
>     function askQuestionERC20(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 tokens) 
>         // stateNotCreated is enforced by the internal _askQuestion
>     public returns (bytes32) {
> 
>         _deductTokensOrRevert(tokens);
260c296
<         _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts);
---
>         _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, tokens);
266c302,327
<     function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts) 
---
>     function _deductTokensOrRevert(uint256 tokens) 
>     internal {
> 
>         if (tokens == 0) {
>             return;
>         }
> 
>         uint256 bal = balanceOf[msg.sender];
> 
>         // Deduct any tokens you have in your internal balance first
>         if (bal > 0) {
>             if (bal >= tokens) {
>                 balanceOf[msg.sender] = bal.sub(tokens);
>                 return;
>             } else {
>                 tokens = tokens.sub(bal);
>                 balanceOf[msg.sender] = 0;
>             }
>         }
>         // Now we need to charge the rest from 
>         require(token.transferFrom(msg.sender, address(this), tokens), "Transfer of tokens failed, insufficient approved balance?");
>         return;
> 
>     }
> 
>     function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 tokens) 
269a331,332
>         uint256 bounty = tokens;
> 
275,276d337
<         uint256 bounty = msg.value;
< 
284c345
<             require(bounty >= question_fee, "ETH provided must cover question fee"); 
---
>             require(bounty >= question_fee, "Tokens provided must cover question fee"); 
300c361,362
<     function fundAnswerBounty(bytes32 question_id) 
---
>     /// @param tokens The number of tokens to fund
>     function fundAnswerBountyERC20(bytes32 question_id, uint256 tokens) 
302,304c364,367
<     external payable {
<         questions[question_id].bounty = questions[question_id].bounty.add(msg.value);
<         emit LogFundAnswerBounty(question_id, msg.value, questions[question_id].bounty, msg.sender);
---
>     external {
>         _deductTokensOrRevert(tokens);
>         questions[question_id].bounty = questions[question_id].bounty.add(tokens);
>         emit LogFundAnswerBounty(question_id, tokens, questions[question_id].bounty, msg.sender);
313c376,377
<     function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) 
---
>     /// @param tokens The amount of tokens to submit
>     function submitAnswerERC20(bytes32 question_id, bytes32 answer, uint256 max_previous, uint256 tokens) 
315c379
<         bondMustDouble(question_id)
---
>         bondMustDouble(question_id, tokens)
317,318c381,383
<     external payable {
<         _addAnswerToHistory(question_id, answer, msg.sender, msg.value, false);
---
>     external {
>         _deductTokensOrRevert(tokens);
>         _addAnswerToHistory(question_id, answer, msg.sender, tokens, false);
341a407
>     /// @param tokens Number of tokens sent
343c409
<     function submitAnswerCommitment(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) 
---
>     function submitAnswerCommitmentERC20(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer, uint256 tokens) 
345c411
<         bondMustDouble(question_id)
---
>         bondMustDouble(question_id, tokens)
347c413
<     external payable {
---
>     external {
349c415,417
<         bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, msg.value));
---
>         _deductTokensOrRevert(tokens);
> 
>         bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, tokens));
350a419
> 
352c421
<         _addAnswerToHistory(question_id, commitment_id, answerer, msg.value, true);
---
>         _addAnswerToHistory(question_id, commitment_id, answerer, tokens, true);
